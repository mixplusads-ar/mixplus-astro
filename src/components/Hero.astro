---
import { site } from '../data/site.ts';
const { lang='fa' } = Astro.props;
const t = site[lang];
---
<section class="hero" aria-label="Hero">
  <video id="heroVideo"
    preload="auto"
    playsinline
    muted
    autoplay
    disablepictureinpicture
    controlslist="nodownload noplaybackrate"
    poster="/media/hero/images/hero-01.jpg"
  ></video>

  <img id="heroFallback" src="/media/hero/images/hero-01.jpg" alt="Hero" style="display:none" loading="eager"/>

  <div class="overlay"></div>
  <div class="content">
    <div>
      <h1>{t.heroTitle}</h1>
      <p>{t.heroText}</p>
      <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap">
        <a class="btn" href={`/${lang}/products/`}>{t.ctaProducts}</a>
        <a class="btn ghost" href={`/${lang}/about/`}>{t.ctaAbout}</a>
      </div>
    </div>
  </div>
</section>

<script>
/**
 * MixPlus Hero Player
 * - Reads videos from /media/hero/videos/video-01.mp4 ... video-04.mp4
 * - Random order, auto-advance, infinite loop (reshuffle after finishing all)
 * - Autoplay-safe (muted/inline + start when visible). If blocked/error -> skip to next.
 * - On theme toggle (html class change) -> restart from a new random video.
 */

const PATH = '/media/hero/videos/';
const FILES = [1,2,3,4].map(n => `video-0${n}.mp4`);

const v = document.getElementById('heroVideo');
const fallback = document.getElementById('heroFallback');

v.muted = true;         // must be true for autoplay policies
v.playsInline = true;   // iOS inline playback
v.autoplay = true;

let queue = [];
let idx = 0;
let started = false;

function shuffle(arr){
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function buildQueue(){
  queue = shuffle(FILES).map(f => PATH + f);
  idx = 0;
}

function setSource(src){
  // Reset <source> for Safari to re-evaluate pipeline
  v.innerHTML = `<source src="${src}" type="video/mp4">`;
  v.load();
}

function showFallback(){
  try{ v.pause(); }catch(_){}
  v.removeAttribute('src');
  v.innerHTML = '';
  v.style.display = 'none';
  fallback.style.display = 'block';
}

async function safePlay(){
  try{
    const p = v.play();
    if (p && typeof p.then === 'function') await p;
  }catch(e){
    // autoplay blocked or decode error -> skip
    playNext();
  }
}

function playCurrent(){
  if (!queue.length) buildQueue();
  const src = queue[idx];
  setSource(src);

  // try play after canplay (reliable across WebKit/Chromium)
  const onCanPlay = () => {
    v.removeEventListener('canplay', onCanPlay);
    // ensure video element is visible (fallback hidden)
    v.style.display = 'block';
    fallback.style.display = 'none';
    safePlay();
  };
  v.addEventListener('canplay', onCanPlay, { once: true });

  // if file errors (404/codec), skip to next one
  const onError = () => {
    v.removeEventListener('error', onError);
    playNext();
  };
  v.addEventListener('error', onError, { once: true });
}

function playNext(){
  if (!queue.length) buildQueue();
  idx++;
  if (idx >= queue.length){
    // Finished all 4 -> reshuffle for infinite random loop
    buildQueue();
  }
  playCurrent();
}

// start only when hero becomes visible (improves autoplay success rate)
function startWhenVisible(){
  if (started) return;
  started = true;
  buildQueue();
  playCurrent();
}
const io = new IntersectionObserver((entries)=>{
  for (const e of entries){
    if (e.isIntersecting){
      startWhenVisible();
      io.disconnect();
      break;
    }
  }
},{ threshold: .15 });
io.observe(document.querySelector('.hero'));

// go to next file on natural end
v.addEventListener('ended', playNext);

// restart from a new random video when theme toggles (class change on <html>)
const html = document.documentElement;
const mo = new MutationObserver(muts=>{
  for (const m of muts){
    if (m.type === 'attributes' && m.attributeName === 'class'){
      // restart with a fresh random queue
      started = false;
      v.pause();
      buildQueue();
      startWhenVisible();
      break;
    }
  }
});
mo.observe(html, { attributes: true });

// safety: start even if hero already visible after hydration
if (document.readyState === 'complete' || document.readyState === 'interactive'){
  // if hero is already on screen, start immediately
  const rect = document.querySelector('.hero')?.getBoundingClientRect();
  if (rect && rect.top < window.innerHeight && rect.bottom > 0) startWhenVisible();
} else {
  document.addEventListener('DOMContentLoaded', ()=>{
    const rect = document.querySelector('.hero')?.getBoundingClientRect();
    if (rect && rect.top < window.innerHeight && rect.bottom > 0) startWhenVisible();
  });
}
</script>
