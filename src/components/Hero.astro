---
import { site } from '../data/site.ts';
const { lang='fa' } = Astro.props;
const t = site[lang];
---
<section class="hero" aria-label="Hero">
  <video id="heroVideo"
    preload="auto"
    playsinline
    muted
    autoplay
    disablepictureinpicture
    controlslist="nodownload noplaybackrate"
    poster="/media/hero/images/hero-01.jpg"
  ></video>

  <img id="heroFallback" src="/media/hero/images/hero-01.jpg" alt="Hero" style="display:none" loading="eager"/>

  <div class="overlay"></div>
  <div class="content">
    <div>
      <h1>{t.heroTitle}</h1>
      <p>{t.heroText}</p>
      <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap">
        <a class="btn" href={`/${lang}/products/`}>{t.ctaProducts}</a>
        <a class="btn ghost" href={`/${lang}/about/`}>{t.ctaAbout}</a>
      </div>
    </div>
  </div>
</section>

<script>
/**
 * Hero video playlist (random order, no loop, go to next on end).
 * IMPORTANT: Looks into /media/hero/video/ (singular) because that's where you uploaded.
 * Files must be named: video-01.mp4 ... video-04.mp4
 */
const base = '/media/hero/video/';
const pool = [1,2,3,4].map(n => `${base}video-0${n}.mp4`);
const sources = pool.sort(() => Math.random() - 0.5);

let idx = 0;
const v = document.getElementById('heroVideo');
const fallback = document.getElementById('heroFallback');

v.muted = true;            // required for autoplay
v.playsInline = true;      // iOS inline playback
v.autoplay = true;

function showFallback(){
  try { v.pause(); } catch(e){}
  v.removeAttribute('src');
  v.innerHTML = '';
  v.style.display = 'none';
  fallback.style.display = 'block';
}

function setSource(src){
  // reset sources for Safari to re-evaluate type
  v.innerHTML = `<source src="${src}" type="video/mp4">`;
  v.load();
}

async function safePlay(){
  try {
    const p = v.play();
    if (p && typeof p.then === 'function') await p;
  } catch (err) {
    // If autoplay is blocked or file not decodable -> fallback
    showFallback();
  }
}

function playNext(){
  if (idx >= sources.length) { showFallback(); return; }
  const src = sources[idx++];
  setSource(src);

  // Wait until video is actually ready, then try play
  const onCanPlay = () => {
    v.removeEventListener('canplay', onCanPlay);
    safePlay();
  };
  v.addEventListener('canplay', onCanPlay, { once: true });

  // If error decoding or 404 -> try next one
  const onError = () => {
    v.removeEventListener('error', onError);
    playNext();
  };
  v.addEventListener('error', onError, { once: true });
}

// Start when hero becomes visible (helps iOS policies)
const startWhenVisible = () => {
  const io = new IntersectionObserver(entries => {
    for (const e of entries) {
      if (e.isIntersecting) {
        playNext();
        io.disconnect();
        break;
      }
    }
  }, { threshold: .2 });
  io.observe(document.querySelector('.hero'));
};

v.addEventListener('ended', playNext);

// Kick off
document.readyState === 'complete' || document.readyState === 'interactive'
  ? startWhenVisible()
  : document.addEventListener('DOMContentLoaded', startWhenVisible);
</script>
